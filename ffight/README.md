# Final Fight

![Andore at start](https://github.com/user-attachments/assets/62648f7e-de08-4460-a915-520712c65192)

## System information

**CPU**
* Motorola MC68000 10 MHz
* Zilog Z80 3.5 MHz

**Specs**<br>
[M68000](../specs/M68000_16_32-Bit_Microprocessor_Programmers_Reference_Manual_4th_Edition_text.pdf)

## General game data

```
0xFF80BE = stage
0xFF80BF = sub stage
0xFF8412 = scene position x (word)
0xFF8129 = stage clear
0xFF812B = boss clear
0xFF845C = scene position y (word)
```

## Character's management

### Player data

Player data is stored on the following addresses:

```
0xFF8568 - Player 1
0xFF8628 - Player 2
```

Starting from these offset, I found the following information stored for each player:

```
O = offset
O + 0x06 = pos x (3 bytes)
O + 0x0A = pos y (word)
O + 0x13 = character (byte, from 0 to 2)
0 + 0x25 = animation frame
...
```

### Objects

0x080F = opening door


### Enemy data

Typically, when an enemy dies the address slot reserved for it get free so when the next enemy spawn on the screen can take it.
This is a bit of content map that an enemy slot can contains:

```
O = offset
O + 0x06	pos x (word)
O + 0x0A pos y (word)
O + 0x12	character
O + 0x13	character
O + 0x14	character
O + 0x15	initial pose
O + 0x18	energy		
O + 0x1C	energy bar size
O + 0x25 frame animation object (double)
...
```

### Boss data

```
O = offset = 0xff9a68
O + 0x06 = pos x (3 bytes)
O + 0x0A = pos y (word)
O + 0x18 = energy
O + 0x1C = energy bar size
```

### Characters

This is the character's available value that I discovered so far:

```
byte position:
12|13|14

02 00 00 = bred
02 00 01 = doug
02 00 02 = jake
02 00 03 = simons
02 01 00 = j
02 01 01 = two.p
02 02 00 = axl
02 02 01 = slash
02 03 00 = andore jr.
02 03 01 = andore
02 03 02 = g.andore
02 04 00 = g. oriber
02 04 01 = bill bull
02 04 02 = wong who
02 05 00 = holly wood
02 05 01 = el gado
02 06 00 = roxy
02 06 01 = poison
02 08 00 = holly wood (red)
```

### Initial pose

Below are some codes I found for the character's initial pose.
<br/>
Behaviour may vary according to the character kind itself, so for instance a value of 0x04 means staying crouched for Bred, while for Andore it means immediately charging the player

```
00 = ?
01 = ?
02 = lean against the wall
04 = ?
06 = ?
07 = coming from a door
0C = coming from above
```

### Special scenes

#### Intro


| ROM     | VALUE  | CHARACTER | MEMORY   |
| ------- | ------ | --------- | -------- |
| 0x6EC91 | 0x2100 | Damnd     | 0xffade9 |
| 0x6EC9F | 0x2101 | Doug      | 0xffad29 |
| 0x6ECAD | 0x2102 | Jake      | 0xffac69 |



All the above characters are generated by Routine B (see Enemy's spawn code chapter)

#### Bonus: Car

```
0xffaea8 = offset = O
O + 0x07  = pos x
O + 0x0B  = pos y
O + 0x13  = character
```

### Enemy's spawn code

Everytime an enemy spawn in the fight, a free ram **slot** of 0xC0 bytes is booked for managing enemy's data, such as animation, position, etc.

Here's an example of slot's map address:

```
1. 0xff8fe8
2. 0xff8f28
3. 0xff8e68
4. 0xff8da8
5. 0xff8ce8
[...]

Boss:
0xff9a68
```

### Stage mapping

There are two main addresses for each stage dedicated for mapping enemies or objects, each of them are scanned by dedicated routines.

For the sake of convenience, we'll call in the following way:

Map routine:

Scan from the vector address and load into memory mapped enemies and objects; enemies contained into this map are not mandatory to beat for advancing the next stage.

These maps are all contained at address 0x06XXXX

Enemy routine:

Scan from the vector address and load into memory mapped enemies that are mandatory to bear in order to advance forward in the lever or to the next stage

These maps are all contained at address 0x07XXXX

```
[slum 1]
0x06D02C
0x070596
[slum 2]
0x06D0CA
0x0705FA
[slum 3]
0x06D122
0x07064E
[subway 1]
0x06D182
0x07071E
[subway 2]
0x06D1F6
0x070792
[subway 3]
0x06D382
0x070866
[subway 4]
0x06D44A
0x0708EA
[west side 1]
0x06D454
0x0708F4
[west side 2]
0x06D4D6
0x070AB6
[west side 3]
0x06D52E
0x070AFA
[industrial area 1]
0x06D5FA
0x070C64
[industrial area 2]
0x06D858
0x070EE8
[bay area]
0x06D968
0x070EEE
[up town 1]
0x06E1C2
0x071364
[up town 2]
0x06E612
0x0714F8
[up town 3]
0x06E8C4
0x07167C
```

It is possible to find out how these addressess are get by the following routines:

```
[Map address]
 00604A  lea     ($2bc,PC) ; ($6308), A3                     47FA 02BC	* = 6D024
 00604E  bsr     $614c                                       6100 00FC
 
	 00614C  moveq   #$0, D0                                     7000
	 00614E  move.b  ($be,A5), D0                                102D 00BE
	 006152  lsl.w   #2, D0                                      E548			    ; 32 bit address
	 006154  movea.l (A3,D0.w), A3                               2673 0000		; get base address for main scenario (from 6308+x)
	 006158  moveq   #$0, D0                                     7000
	 00615A  move.b  ($bf,A5), D0                                102D 00BF
	 00615E  add.w   D0, D0                                      D040
	 006160  move.w  (A3,D0.w), D0                               3033 0000		
	 006164  lea     (A3,D0.w), A3                               47F3 0000		; get base address + delta for sub scenario
	 006168  rts                                                 4E75
	 
 006052  move.w  (A3)+, ($24,A6)                             3D5B 0024
 006056  move.l  A3, ($20,A6)                                2D4B 0020		; get final address in A3
 00605A  rts                                                 4E75       ; place a breakpoint here !

...


[Enemy address]
005ADC  lea     ($442,PC) ; ($5f20), A3                     47FA 0442
005AE0  tst.w   $72600.l                                    4A79 0007 2600
005AE6  beq     $5aec                                       6704
005AE8  lea     ($456,PC) ; ($5f40), A3                     47FA 0456
005AEC  move.b  ($be,A5), D0                                102D 00BE
005AF0  lsl.w   #2, D0                                      E548
005AF2  movea.l (A3,D0.w), A3                               2673 0000
005AF6  moveq   #$0, D0                                     7000
005AF8  move.b  ($bf,A5), D0                                102D 00BF
005AFC  add.w   D0, D0                                      D040
005AFE  move.w  (A3,D0.w), D0                               3033 0000
005B02  lea     (A3,D0.w), A3                               47F3 0000		
005B06  move.w  (A3)+, ($a,A6)                              3D5B 000A		; get base address + delta for sub scenario
005B0A  move.l  A3, ($6,A6)                                 2D4B 0006
005B0E  rts                                                 4E75       ; place a breakpoint here !
```


#### Map routine

Here's an example of the first stage map (slum 1), located at address 0x06D02C:

```
O + 0x00 = when 0xFF8412 == value, then load into memory
O + 0x02 = position x (word)
O + 0x04 = position y (word)
O + 0x06 = character / object	(3 bytes)
O + 0x09 = initial pose (if character)
O + 0x08 = object contained (if object)
O + 0x0D = if value == 1, enabled only with two players

06D02C   0070  0210  0040  0200  0002  0000  0000   .p...@........
06D03A   0140  0228  00B8  080F  0000  0000  0000   .@.(.¸........
06D048   0150  02F0  003F  0A08  0186  0000  0000   .P.ð.?........
06D056   0190  0330  0040  0201  0002  0000  0000   ...0.@........
06D064   01C8  01A8  0028  0201  0000  0000  0000   .È.¨.(........
06D072   01C8  0368  003F  0A05  0187  0000  0000   .È.h.?........
06D080   01F8  0398  003F  0A05  0184  0000  0000   .ø...?........
06D08E   02B0  03B8  00B8  080F  0100  0000  0000   .°.¸.¸........
06D09C   0308  04A8  003F  0A05  0183  0000  0000   ...¨.?........
06D0AA   0338  04D8  003F  0A05  0503  0000  0000   .8.Ø.?........
06D0B8   03A0  0540  0019  0A05  028E  0000  0000   . .@..........
06D0C6   FFFF  0002  0650  06E0  003F  0A04  0126   ÿÿ...P.à.?...&
```

We can divide each block by 0x0E bytes, so we have first offset starting at 0x06D02C, then the next ones at 0x06D03A,0x06D048 and so on.

#### Enemies routine

Below's the enemy's map of the first stage (slum 1)

```
O + 0x00 = when 0xFF8412 == value, then load into memory
enemy:
O + 0x00 = position x (word)
O + 0x02 = position y (word)
O + 0x04 = character / pose (double)
...

070596   03F0  1C20  0005  0000  0000  0007  05F4  0001  0001   .ð. .........
0705A8   03D0  0034  0200  0100  0000  0000  001E  0001         .Ð.4............
0705B8   03D0  0021  0200  0000  0000  0000  003C  0001         .Ð.!.........<..
0705C8   03D0  0034  0205  0000  0000  0000  001E  0001         .Ð.4............
0705D8   03D0  0021  0202  0000  0000  0400  001E  0001         .Ð.!............
0705E8   03D0  0021  0201  0000  0000  0001  8004  7FFF         .Ð.!...........ÿ

```

While the first offset takes 0x12 bytes to store general information, the other ones takes 0x10 bytes for storing enemy information


### Bosses

```
04 0000 = Damnd
04 0100 = Sodom
04 0200 = Edi.E
04 0300 = Rolento
04 0400 = Abigail
04 0500 = Belger
04 0600 = Bosstest
```
